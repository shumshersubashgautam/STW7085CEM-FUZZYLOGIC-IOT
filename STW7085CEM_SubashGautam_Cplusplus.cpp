//Code automatically generated with fuzzylite 6.0.

using namespace fl;

Engine* engine = new Engine;
engine->setName("");
engine->setDescription("");

InputVariable* t_ins = new InputVariable;
t_ins->setName("t_ins");
t_ins->setDescription("Temperature inside the flat (in Celsius degrees)");
t_ins->setEnabled(true);
t_ins->setRange(-10.000, 30.000);
t_ins->setLockValueInRange(false);
t_ins->addTerm(new Trapezoid("very_low", -10.000, -10.000, -4.000, 0.400));
t_ins->addTerm(new Trapezoid("low", -6.000, -4.000, 5.200, 8.800));
t_ins->addTerm(new Trapezoid("neutral", 6.000, 8.000, 12.800, 14.400));
t_ins->addTerm(new Trapezoid("high", 12.400, 15.600, 21.600, 23.200));
t_ins->addTerm(new Trapezoid("very_high", 18.600, 21.600, 30.000, 30.000));
engine->addInputVariable(t_ins);

InputVariable* t_out = new InputVariable;
t_out->setName("t_out");
t_out->setDescription("temperature outside the flat (in Celsius degrees)");
t_out->setEnabled(true);
t_out->setRange(-30.000, 30.000);
t_out->setLockValueInRange(false);
t_out->addTerm(new Trapezoid("very_low", -30.000, -30.000, -20.000, -18.000));
t_out->addTerm(new Trapezoid("low", -20.000, -18.000, -8.000, -6.000));
t_out->addTerm(new Trapezoid("neutral", -8.000, -6.000, 4.000, 6.000));
t_out->addTerm(new Trapezoid("high", 4.000, 6.000, 16.000, 18.000));
t_out->addTerm(new Trapezoid("very_high", 16.000, 18.000, 30.000, 30.000));
engine->addInputVariable(t_out);

InputVariable* havc_power = new InputVariable;
havc_power->setName("havc_power");
havc_power->setDescription("power of HAVC (off or on)");
havc_power->setEnabled(true);
havc_power->setRange(0.000, 2.000);
havc_power->setLockValueInRange(false);
havc_power->addTerm(new Binary("off", 0.999, -inf));
havc_power->addTerm(new Binary("on", 1.000, inf));
engine->addInputVariable(havc_power);

InputVariable* rain = new InputVariable;
rain->setName("rain");
rain->setDescription("strength of the rain (in %)");
rain->setEnabled(true);
rain->setRange(0.000, 100.000);
rain->setLockValueInRange(false);
rain->addTerm(new Triangle("light", 0.000, 0.000, 65.000));
rain->addTerm(new Triangle("heavy", 35.000, 100.000, 100.000));
engine->addInputVariable(rain);

InputVariable* light_out = new InputVariable;
light_out->setName("light_out");
light_out->setDescription("brightness outside (in %)");
light_out->setEnabled(true);
light_out->setRange(0.000, 100.000);
light_out->setLockValueInRange(false);
light_out->addTerm(new Triangle("dark", 0.000, 0.000, 50.000));
light_out->addTerm(new Triangle("medium", 0.001, 50.000, 99.999));
light_out->addTerm(new Triangle("bright", 50.000, 100.000, 100.000));
engine->addInputVariable(light_out);

InputVariable* room_window = new InputVariable;
room_window->setName("room_window");
room_window->setDescription("the presence of a window in a room (yes or no)");
room_window->setEnabled(true);
room_window->setRange(0.000, 2.000);
room_window->setLockValueInRange(false);
room_window->addTerm(new Binary("no", 0.999, -inf));
room_window->addTerm(new Binary("yes", 1.000, inf));
engine->addInputVariable(room_window);

InputVariable* sound_detector = new InputVariable;
sound_detector->setName("sound_detector");
sound_detector->setDescription("sound level detection (in dB)");
sound_detector->setEnabled(true);
sound_detector->setRange(0.000, 130.000);
sound_detector->setLockValueInRange(false);
sound_detector->addTerm(new Triangle("quiet", 0.000, 0.000, 80.000));
sound_detector->addTerm(new Triangle("loud", 50.000, 130.000, 130.000));
engine->addInputVariable(sound_detector);

InputVariable* word_detector = new InputVariable;
word_detector->setName("word_detector");
word_detector->setDescription("detector of word "alexa help" (yes or no)");
word_detector->setEnabled(true);
word_detector->setRange(0.000, 2.000);
word_detector->setLockValueInRange(false);
word_detector->addTerm(new Trapezoid("not_help", 0.000, 0.000, 0.750, 1.250));
word_detector->addTerm(new Trapezoid("help", 0.750, 1.250, 2.000, 2.000));
engine->addInputVariable(word_detector);

InputVariable* pulse_sensor = new InputVariable;
pulse_sensor->setName("pulse_sensor");
pulse_sensor->setDescription("pulse rate measured (in bpm)");
pulse_sensor->setEnabled(true);
pulse_sensor->setRange(0.000, 120.000);
pulse_sensor->setLockValueInRange(false);
pulse_sensor->addTerm(new Trapezoid("dangerous_below_limit", 0.000, 0.000, 35.000, 42.500));
pulse_sensor->addTerm(new Trapezoid("athlete", 39.000, 40.000, 60.000, 62.500));
pulse_sensor->addTerm(new Trapezoid("normal", 58.500, 60.000, 100.000, 102.500));
pulse_sensor->addTerm(new Trapezoid("dangerous_over_limit", 99.000, 100.000, 120.000, 120.000));
engine->addInputVariable(pulse_sensor);

InputVariable* closed_opened_sensor = new InputVariable;
closed_opened_sensor->setName("closed_opened_sensor");
closed_opened_sensor->setDescription("door sensor determining if the doors are fully closed or opened");
closed_opened_sensor->setEnabled(true);
closed_opened_sensor->setRange(0.000, 3.000);
closed_opened_sensor->setLockValueInRange(false);
closed_opened_sensor->addTerm(new Rectangle("none", 0.000, 0.999));
closed_opened_sensor->addTerm(new Rectangle("closed", 1.000, 2.000));
closed_opened_sensor->addTerm(new Rectangle("opened", 2.000, 3.000));
engine->addInputVariable(closed_opened_sensor);

InputVariable* motion_detector_doors = new InputVariable;
motion_detector_doors->setName("motion_detector_doors");
motion_detector_doors->setDescription("threshold of pixels that has to change in a moment (determined in a number of pixels)");
motion_detector_doors->setEnabled(true);
motion_detector_doors->setRange(0.000, 30000.000);
motion_detector_doors->setLockValueInRange(false);
motion_detector_doors->addTerm(new Trapezoid("below_threshold", 0.000, 0.000, 14000.000, 16000.000));
motion_detector_doors->addTerm(new Trapezoid("above_threshold", 14000.000, 16000.000, 30000.000, 30000.000));
engine->addInputVariable(motion_detector_doors);

InputVariable* time_of_opened_doors = new InputVariable;
time_of_opened_doors->setName("time_of_opened_doors");
time_of_opened_doors->setDescription("time of opened doors below threshold (measured in seconds)");
time_of_opened_doors->setEnabled(true);
time_of_opened_doors->setRange(0.000, 50.000);
time_of_opened_doors->setLockValueInRange(false);
time_of_opened_doors->addTerm(new Trapezoid("less_than_25seconds", 0.000, 0.000, 24.000, 26.000));
time_of_opened_doors->addTerm(new Trapezoid("more_than_25seconds", 24.000, 26.000, 50.000, 50.000));
engine->addInputVariable(time_of_opened_doors);

InputVariable* pressure_on_elevator = new InputVariable;
pressure_on_elevator->setName("pressure_on_elevator");
pressure_on_elevator->setDescription("pressure on the elevator with a limit of 360 (measured in kg)");
pressure_on_elevator->setEnabled(true);
pressure_on_elevator->setRange(0.000, 450.000);
pressure_on_elevator->setLockValueInRange(false);
pressure_on_elevator->addTerm(new Trapezoid("below_limit", 0.000, 0.000, 350.000, 370.000));
pressure_on_elevator->addTerm(new Trapezoid("over_limit", 350.000, 370.000, 450.000, 450.000));
engine->addInputVariable(pressure_on_elevator);

InputVariable* number_of_people_in_elevator = new InputVariable;
number_of_people_in_elevator->setName("number_of_people_in_elevator");
number_of_people_in_elevator->setDescription("number of people in the elevator with a limit of 4 (yes or no)");
number_of_people_in_elevator->setEnabled(true);
number_of_people_in_elevator->setRange(0.000, 6.000);
number_of_people_in_elevator->setLockValueInRange(false);
number_of_people_in_elevator->addTerm(new Binary("below_limit", 4.000, -inf));
number_of_people_in_elevator->addTerm(new Binary("over_limit", 4.001, inf));
engine->addInputVariable(number_of_people_in_elevator);

InputVariable* speed_of_orientation_change = new InputVariable;
speed_of_orientation_change->setName("speed_of_orientation_change");
speed_of_orientation_change->setDescription("speed of orientation change of the person wearing the sensor (measured in seconds)");
speed_of_orientation_change->setEnabled(true);
speed_of_orientation_change->setRange(0.000, 3.000);
speed_of_orientation_change->setLockValueInRange(false);
speed_of_orientation_change->addTerm(new Rectangle("none", 0.000, 0.000));
speed_of_orientation_change->addTerm(new Trapezoid("fast", 0.001, 0.001, 1.250, 1.750));
speed_of_orientation_change->addTerm(new Trapezoid("normal", 1.250, 1.750, 3.000, 3.000));
engine->addInputVariable(speed_of_orientation_change);

InputVariable* orientation_of_person_after_change = new InputVariable;
orientation_of_person_after_change->setName("orientation_of_person_after_change");
orientation_of_person_after_change->setDescription("orientation of person after change (yes or no)");
orientation_of_person_after_change->setEnabled(true);
orientation_of_person_after_change->setRange(0.000, 2.000);
orientation_of_person_after_change->setLockValueInRange(false);
orientation_of_person_after_change->addTerm(new Trapezoid("vertical", 0.000, 0.000, 0.750, 1.250));
orientation_of_person_after_change->addTerm(new Trapezoid("horizontal", 0.750, 1.250, 2.000, 2.000));
engine->addInputVariable(orientation_of_person_after_change);

InputVariable* time_on_the_ground = new InputVariable;
time_on_the_ground->setName("time_on_the_ground");
time_on_the_ground->setDescription("time of a person in horizontal position on the ground (measured in minutes)");
time_on_the_ground->setEnabled(true);
time_on_the_ground->setRange(0.000, 90.000);
time_on_the_ground->setLockValueInRange(false);
time_on_the_ground->addTerm(new Trapezoid("less_than_1_hour", 0.000, 0.000, 58.000, 62.000));
time_on_the_ground->addTerm(new Trapezoid("more_than_1_hour", 58.000, 62.000, 90.000, 90.000));
engine->addInputVariable(time_on_the_ground);

OutputVariable* havc = new OutputVariable;
havc->setName("havc");
havc->setDescription("power given by heater, air ventilation, heater (in Celsius degrees)");
havc->setEnabled(true);
havc->setRange(-30.000, 30.000);
havc->setLockValueInRange(false);
havc->setAggregation(new Maximum);
havc->setDefuzzifier(new Centroid(100));
havc->setDefaultValue(fl::nan);
havc->setLockPreviousValue(false);
havc->addTerm(new Triangle("cooler", -30.000, -30.000, -2.000));
havc->addTerm(new Triangle("air_ventilation", -5.000, 0.000, 5.000));
havc->addTerm(new Triangle("heater", 2.000, 30.000, 30.000));
engine->addOutputVariable(havc);

OutputVariable* windows = new OutputVariable;
windows->setName("windows");
windows->setDescription("openess of windows (in %)");
windows->setEnabled(true);
windows->setRange(0.000, 100.000);
windows->setLockValueInRange(false);
windows->setAggregation(new Maximum);
windows->setDefuzzifier(new Centroid(100));
windows->setDefaultValue(fl::nan);
windows->setLockPreviousValue(false);
windows->addTerm(new Triangle("close", 0.000, 0.000, 20.000));
windows->addTerm(new Triangle("open", 0.000, 100.000, 100.000));
engine->addOutputVariable(windows);

OutputVariable* artificial_light_ins = new OutputVariable;
artificial_light_ins->setName("artificial_light_ins");
artificial_light_ins->setDescription("brightness inside given by the light bulbs (in %)");
artificial_light_ins->setEnabled(true);
artificial_light_ins->setRange(0.000, 100.000);
artificial_light_ins->setLockValueInRange(false);
artificial_light_ins->setAggregation(new Maximum);
artificial_light_ins->setDefuzzifier(new Centroid(100));
artificial_light_ins->setDefaultValue(fl::nan);
artificial_light_ins->setLockPreviousValue(false);
artificial_light_ins->addTerm(new Rectangle("off", 0.000, 0.000));
artificial_light_ins->addTerm(new Trapezoid("medium", 0.001, 0.001, 32.500, 65.000));
artificial_light_ins->addTerm(new Triangle("bright", 32.500, 100.000, 100.000));
engine->addOutputVariable(artificial_light_ins);

OutputVariable* curtains = new OutputVariable;
curtains->setName("curtains");
curtains->setDescription("openess of curtains (in %)");
curtains->setEnabled(true);
curtains->setRange(0.000, 100.000);
curtains->setLockValueInRange(false);
curtains->setAggregation(new Maximum);
curtains->setDefuzzifier(new Centroid(100));
curtains->setDefaultValue(fl::nan);
curtains->setLockPreviousValue(false);
curtains->addTerm(new Triangle("close", 0.000, 0.000, 20.000));
curtains->addTerm(new Triangle("open", 0.000, 100.000, 100.000));
engine->addOutputVariable(curtains);

OutputVariable* call_patron = new OutputVariable;
call_patron->setName("call_patron");
call_patron->setDescription("decision if to call a patron - based on sound detector (in %)");
call_patron->setEnabled(true);
call_patron->setRange(0.000, 100.000);
call_patron->setLockValueInRange(false);
call_patron->setAggregation(new Maximum);
call_patron->setDefuzzifier(new Centroid(100));
call_patron->setDefaultValue(fl::nan);
call_patron->setLockPreviousValue(false);
call_patron->addTerm(new Triangle("no", 0.000, 0.000, 99.999));
call_patron->addTerm(new Triangle("yes", 0.001, 100.000, 100.000));
engine->addOutputVariable(call_patron);

OutputVariable* notify_doctor = new OutputVariable;
notify_doctor->setName("notify_doctor");
notify_doctor->setDescription("decision if to notify a doctor - based on pulse sensor (in %)");
notify_doctor->setEnabled(true);
notify_doctor->setRange(0.000, 100.000);
notify_doctor->setLockValueInRange(false);
notify_doctor->setAggregation(new Maximum);
notify_doctor->setDefuzzifier(new Centroid(100));
notify_doctor->setDefaultValue(fl::nan);
notify_doctor->setLockPreviousValue(false);
notify_doctor->addTerm(new Triangle("no", 0.000, 0.000, 99.999));
notify_doctor->addTerm(new Triangle("yes", 0.001, 100.000, 100.000));
engine->addOutputVariable(notify_doctor);

OutputVariable* state_of_doors = new OutputVariable;
state_of_doors->setName("state_of_doors");
state_of_doors->setDescription("doors are either closed, closing, opening or opened");
state_of_doors->setEnabled(true);
state_of_doors->setRange(0.000, 4.000);
state_of_doors->setLockValueInRange(false);
state_of_doors->setAggregation(new Maximum);
state_of_doors->setDefuzzifier(new Centroid(100));
state_of_doors->setDefaultValue(fl::nan);
state_of_doors->setLockPreviousValue(false);
state_of_doors->addTerm(new Triangle("closed", 0.000, 0.000, 1.000));
state_of_doors->addTerm(new Trapezoid("closing", 0.001, 1.001, 1.999, 1.999));
state_of_doors->addTerm(new Trapezoid("opening", 2.000, 2.000, 3.000, 4.000));
state_of_doors->addTerm(new Triangle("opened", 3.000, 4.000, 4.000));
engine->addOutputVariable(state_of_doors);

OutputVariable* alarm_in_elevator = new OutputVariable;
alarm_in_elevator->setName("alarm_in_elevator");
alarm_in_elevator->setDescription("alarm sound in elevator (on or off)");
alarm_in_elevator->setEnabled(true);
alarm_in_elevator->setRange(0.000, 1.000);
alarm_in_elevator->setLockValueInRange(false);
alarm_in_elevator->setAggregation(new Maximum);
alarm_in_elevator->setDefuzzifier(new Centroid(100));
alarm_in_elevator->setDefaultValue(fl::nan);
alarm_in_elevator->setLockPreviousValue(false);
alarm_in_elevator->addTerm(new Trapezoid("off", 0.000, 0.000, 0.400, 0.600));
alarm_in_elevator->addTerm(new Trapezoid("on", 0.400, 0.600, 1.000, 1.000));
engine->addOutputVariable(alarm_in_elevator);

OutputVariable* fall_sensor = new OutputVariable;
fall_sensor->setName("fall_sensor");
fall_sensor->setDescription("decision of what fall sensor should do - based on patient behaviour");
fall_sensor->setEnabled(true);
fall_sensor->setRange(0.000, 3.000);
fall_sensor->setLockValueInRange(false);
fall_sensor->setAggregation(new Maximum);
fall_sensor->setDefuzzifier(new Centroid(100));
fall_sensor->setDefaultValue(fl::nan);
fall_sensor->setLockPreviousValue(false);
fall_sensor->addTerm(new Trapezoid("none", 0.000, 0.000, 0.900, 1.100));
fall_sensor->addTerm(new Trapezoid("notify", 0.900, 1.100, 1.900, 2.100));
fall_sensor->addTerm(new Trapezoid("notify_and_register_for_special_examination", 1.900, 2.100, 3.000, 3.000));
engine->addOutputVariable(fall_sensor);

RuleBlock* havc_on = new RuleBlock;
havc_on->setName("havc_on");
havc_on->setDescription("control of windows and HAVC when HAVC is on");
havc_on->setEnabled(true);
havc_on->setConjunction(new Minimum);
havc_on->setDisjunction(new Maximum);
havc_on->setImplication(new Minimum);
havc_on->setActivation(new General);
havc_on->addRule(Rule::parse("if havc_power is on and t_ins is very_low then havc is very heater and windows is close", engine));
havc_on->addRule(Rule::parse("if havc_power is on and t_ins is low then havc is heater and windows is close", engine));
havc_on->addRule(Rule::parse("if havc_power is on and t_ins is neutral then havc is air_ventilation and windows is close", engine));
havc_on->addRule(Rule::parse("if havc_power is on and t_ins is high then havc is cooler and windows is close", engine));
havc_on->addRule(Rule::parse("if havc_power is on and t_ins is very_high then havc is very cooler and windows is close", engine));
engine->addRuleBlock(havc_on);

RuleBlock* havc_off = new RuleBlock;
havc_off->setName("havc_off");
havc_off->setDescription("control of windows when HAVC is off");
havc_off->setEnabled(true);
havc_off->setConjunction(new Minimum);
havc_off->setDisjunction(new Maximum);
havc_off->setImplication(new Minimum);
havc_off->setActivation(new General);
havc_off->addRule(Rule::parse("if havc_power is off and rain is very heavy then windows is close", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is very_low and t_out is very_low then windows is somewhat open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is very_low and t_out is low then windows is open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is very_low and t_out is neutral then windows is very open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is very_low and t_out is high then windows is extremely open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is very_low and t_out is very_high then windows is any open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is low and t_out is very_low then windows is seldom open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is low and t_out is low then windows is somewhat open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is low and t_out is neutral then windows is open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is low and t_out is high then windows is very open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is low and t_out is very_high then windows is extremely open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is neutral and t_out is very_high then windows is seldom open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is neutral and t_out is high then windows is somewhat open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is neutral and t_out is neutral then windows is open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is neutral and t_out is low then windows is somewhat open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is neutral and t_out is very_low then windows is seldom open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is high and t_out is very_low then windows is extremely open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is high and t_out is low then windows is very open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is high and t_out is neutral then windows is open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is high and t_out is high then windows is somewhat open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is high and t_out is very_high then windows is seldom open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is very_high and t_out is very_low then windows is any open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is very_high and t_out is low then windows is extremely open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is very_high and t_out is neutral then windows is very open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is very_high and t_out is high then windows is open", engine));
havc_off->addRule(Rule::parse("if havc_power is off and rain is light and t_ins is very_high and t_out is very_high then windows is somewhat open", engine));
engine->addRuleBlock(havc_off);

RuleBlock* light = new RuleBlock;
light->setName("light");
light->setDescription("light control inside the house");
light->setEnabled(true);
light->setConjunction(new Minimum);
light->setDisjunction(new Maximum);
light->setImplication(new Minimum);
light->setActivation(new General);
light->addRule(Rule::parse("if room_window is no then artificial_light_ins is bright", engine));
light->addRule(Rule::parse("if room_window is yes and light_out is dark then artificial_light_ins is bright and curtains is close", engine));
light->addRule(Rule::parse("if room_window is yes and light_out is medium then artificial_light_ins is medium and curtains is somewhat open", engine));
light->addRule(Rule::parse("if room_window is yes and light_out is bright then artificial_light_ins is off and curtains is very open", engine));
engine->addRuleBlock(light);

RuleBlock* call_patron = new RuleBlock;
call_patron->setName("call_patron");
call_patron->setDescription("decision if to call a patron");
call_patron->setEnabled(true);
call_patron->setConjunction(new Minimum);
call_patron->setDisjunction(new Maximum);
call_patron->setImplication(new Minimum);
call_patron->setActivation(new General);
call_patron->addRule(Rule::parse("if sound_detector is quiet and word_detector is not_help then call_patron is no", engine));
call_patron->addRule(Rule::parse("if sound_detector is quiet and word_detector is help then call_patron is yes", engine));
call_patron->addRule(Rule::parse("if sound_detector is loud then call_patron is yes", engine));
engine->addRuleBlock(call_patron);

RuleBlock* pulse_sensor = new RuleBlock;
pulse_sensor->setName("pulse_sensor");
pulse_sensor->setDescription("decision if to notify a doctor");
pulse_sensor->setEnabled(true);
pulse_sensor->setConjunction(new Minimum);
pulse_sensor->setDisjunction(new Maximum);
pulse_sensor->setImplication(new Minimum);
pulse_sensor->setActivation(new General);
pulse_sensor->addRule(Rule::parse("if pulse_sensor is dangerous_below_limit then notify_doctor is any yes", engine));
pulse_sensor->addRule(Rule::parse("if pulse_sensor is athlete then notify_doctor is very somewhat no", engine));
pulse_sensor->addRule(Rule::parse("if pulse_sensor is normal then notify_doctor is no", engine));
pulse_sensor->addRule(Rule::parse("if pulse_sensor is dangerous_over_limit then notify_doctor is any yes", engine));
engine->addRuleBlock(pulse_sensor);

RuleBlock* doors = new RuleBlock;
doors->setName("doors");
doors->setDescription("opening and closing doors");
doors->setEnabled(true);
doors->setConjunction(new Minimum);
doors->setDisjunction(new Maximum);
doors->setImplication(new Minimum);
doors->setActivation(new General);
doors->addRule(Rule::parse("if closed_opened_sensor is closed then state_of_doors is closed with 0.5", engine));
doors->addRule(Rule::parse("if closed_opened_sensor is opened then state_of_doors is opened with 0.5", engine));
doors->addRule(Rule::parse("if motion_detector_doors is above_threshold then state_of_doors is opening with 1", engine));
doors->addRule(Rule::parse("if motion_detector_doors is below_threshold and time_of_opened_doors is more_than_25seconds then state_of_doors is closing with 1", engine));
engine->addRuleBlock(doors);

RuleBlock* alarm_in_elevator = new RuleBlock;
alarm_in_elevator->setName("alarm_in_elevator");
alarm_in_elevator->setDescription("decision if to turn on the alarm in elevator");
alarm_in_elevator->setEnabled(true);
alarm_in_elevator->setConjunction(new Minimum);
alarm_in_elevator->setDisjunction(new Maximum);
alarm_in_elevator->setImplication(new Minimum);
alarm_in_elevator->setActivation(new General);
alarm_in_elevator->addRule(Rule::parse("if pressure_on_elevator is below_limit and number_of_people_in_elevator is below_limit then alarm_in_elevator is off", engine));
alarm_in_elevator->addRule(Rule::parse("if pressure_on_elevator is below_limit and number_of_people_in_elevator is over_limit then alarm_in_elevator is on", engine));
alarm_in_elevator->addRule(Rule::parse("if pressure_on_elevator is over_limit and number_of_people_in_elevator is below_limit then alarm_in_elevator is on", engine));
alarm_in_elevator->addRule(Rule::parse("if pressure_on_elevator is over_limit and number_of_people_in_elevator is over_limit then alarm_in_elevator is on", engine));
engine->addRuleBlock(alarm_in_elevator);

RuleBlock* fall_detector = new RuleBlock;
fall_detector->setName("fall_detector");
fall_detector->setDescription("determination what the fall detector should do");
fall_detector->setEnabled(true);
fall_detector->setConjunction(new Minimum);
fall_detector->setDisjunction(new Maximum);
fall_detector->setImplication(new Minimum);
fall_detector->setActivation(new General);
fall_detector->addRule(Rule::parse("if speed_of_orientation_change is normal and orientation_of_person_after_change is horizontal and time_on_the_ground is more_than_1_hour then fall_sensor is notify", engine));
fall_detector->addRule(Rule::parse("if speed_of_orientation_change is fast and orientation_of_person_after_change is horizontal and time_on_the_ground is less_than_1_hour then fall_sensor is notify", engine));
fall_detector->addRule(Rule::parse("if speed_of_orientation_change is fast and orientation_of_person_after_change is horizontal and time_on_the_ground is more_than_1_hour then fall_sensor is notify_and_register_for_special_examination", engine));
fall_detector->addRule(Rule::parse("if speed_of_orientation_change is normal and orientation_of_person_after_change is horizontal and time_on_the_ground is less_than_1_hour then fall_sensor is none", engine));
fall_detector->addRule(Rule::parse("if speed_of_orientation_change is normal and orientation_of_person_after_change is vertical and time_on_the_ground is less_than_1_hour then fall_sensor is none", engine));
fall_detector->addRule(Rule::parse("if speed_of_orientation_change is normal and orientation_of_person_after_change is vertical and time_on_the_ground is more_than_1_hour then fall_sensor is none", engine));
fall_detector->addRule(Rule::parse("if speed_of_orientation_change is fast and orientation_of_person_after_change is vertical and time_on_the_ground is less_than_1_hour then fall_sensor is none", engine));
fall_detector->addRule(Rule::parse("if speed_of_orientation_change is fast and orientation_of_person_after_change is vertical and time_on_the_ground is more_than_1_hour then fall_sensor is none", engine));
engine->addRuleBlock(fall_detector);

